theory ThirdEATImplementation
begin
builtins: asymmetric-encryption, revealing-signing

// in this model the verifier and the relying party are the same entity
// this is a reasonable simplification since the verifier and relying party trust each other
// and in some instances they are the same identity

rule create_identities:
    [Fr(~ltk)] //generate new fresh longterm-key
    --[Create_ident($A, ~ltk)]->
    [!Identity($A, ~ltk, pk(~ltk)), Out(pk(~ltk)), AttesterState($A, 'good')]  // Comment to self: AttesterState should not be persistent


// rule Verifier_sends_Nonce_to_Attester: 
//     let 
//         signed_nonce = revealSign(~n, ~Vltk)
//     in
//     [!Identity($Attester, ~Altk, pk(~Altk)), Fr(~n), !Identity($Verifier, ~Vltk, pk(~Vltk)) ]
//     --[VerifierSendsNonce($Attester, $Verifier, signed_nonce)]->
//     [Out(<$Verifier, $Attester, signed_nonce>), Nonce(~n), Verifier0($Verifier, $Attester, pk(~Altk), ~n, ~Vltk)] // Nonce(~n) , Attester0($Attester, ~Altk, pk(~Altk))


rule Verifier_sends_Nonce_to_Attester: 
    let 
        signed_nonce = revealSign(~n, ~Vltk)
        // signed_nonce = revealSign(~n, pk(~Vltk))

    in
    [!Identity($Attester, ~Altk, pk(~Altk)), Fr(~n), !Identity($Verifier, ~Vltk, pk(~Vltk))]
    --[VerifierSendsNonce($Attester, $Verifier, signed_nonce)]-> 
    [Out(<$Verifier, $Attester, signed_nonce>), Nonce(~n), Verifier0($Verifier, $Attester, pk(~Altk), ~n, ~Vltk)]




// rule attester goes rouge
// AttesterState($Attester, 'good'/'bad')
// AttesterState($attester, 'good') -[AttesterCompromise($Attester)]-> AttesterState($attester, 'bad')
rule attester_Gets_compromised:
    [AttesterState($Attester, 'good')]
    --[AttesterCompromise($Attester)]->
    [AttesterState($Attester, 'bad')]




// AttesterState($Attester, 'good') -[CompleteCompromise($Attester)]-> Out(~Altk)

// AttesterState($Attester, 'bad') -[RegainControl($Attester)]-> AttesterState($Attester, 'good')


//=========================================================================================================================================


rule Atterster_create_and_sends_EAT_good:
    let
        attester_data = 'good_state' // Check that you're ein a good state and send good firmware
        EAT = <signed_nonce, attester_data>
        signed_EAT = revealSign(EAT, ~Altk)
    in
    [
        !Identity($Attester, ~Altk, pk(~Altk)), 
        In(<$Verifier, $Attester, signed_nonce>), 
        AttesterState($Attester, 'good')
    ]
    --[AttesterSendsEatGood($Attester, $Verifier, signed_EAT, signed_nonce)]->
    [Out(<$Attester, $Verifier, signed_EAT>)] //, Out(~Altk)

// rule for offering a signing interface to the attacker when the attester is compromised
// AttesterState($Attester, 'bad') , In(messageToSign) -[...]-> Out(revealSign(messageToSign, ~Altk))    
rule Atterster_create_and_sends_EAT_bad:
    let
        attester_data = 'bad_state' // check that you're in a bad state and send bad_firmware
        EAT = <signed_nonce, attester_data>
        signed_EAT = revealSign(EAT, ~Altk)
        // there's no explicit test for the authenticity and integrity of signed_nonce
    in
    [ 
        !Identity($Attester, ~Altk, pk(~Altk)),
        In(<$Verifier, $Atterster, signed_nonce>),
        AttesterState($Attester, 'bad')
    ]
    --[AttesterSendsEatBad($Attester, $Verifier, signed_EAT, signed_nonce )]->
    [Out(<$Attester, $Verifier, signed_EAT>)] 

//=========================================================================================================================================



// rule Verifier_recieve_and_verify_EAT:
//     let 
//         EAT = getMessage(signed_EAT) //get message without key, only something a "simulator actor" can do
//         check_signature = revealVerify(signed_EAT, EAT, pk(~Altk))
//         unpacked_nonce = fst(EAT)
//         unpacked_state = snd(EAT)
//     in    
//     [Verifier0($Verifier, $Attester, pk(~Altk), ~n, ~Vltk), Nonce(~n), !Identity($Attester, ~Altk, pk(~Altk)),  In(<$Attester, $Verfier, signed_EAT>)]
//     --[VerifierVerifiesEat($Attester, $Verifier, signed_EAT, ~n),
//         Eq(unpacked_nonce, ~n),
//         Eq(check_signature, true),
//         // Eq(unpacked_nonce, true),
//         Eq(unpacked_state,'good_state')
//       ]->
//     [EatAuthenticityVerified($Attester, $Verifier, signed_EAT, ~n)]



rule Verifier_recieve_and_verify_EAT:
    let 
        EAT = getMessage(signed_EAT) // Get message without key, only something a "simulator actor" can do
        check_signature = revealVerify(signed_EAT, EAT, pk(~Altk))
        unpacked_nonce = fst(EAT)
        unpacked_state = snd(EAT)
    in    
    [Verifier0($Verifier, $Attester, pk(~Altk), ~n, ~Vltk), Nonce(~n), !Identity($Attester, ~Altk, pk(~Altk)),  In(<$Attester, $Verifier, signed_EAT>)]
    --[VerifierVerifiesEat($Attester, $Verifier, signed_EAT, ~n),
        Eq(unpacked_nonce, ~n),
        Eq(check_signature, true),
        Eq(unpacked_state, 'good_state')
      ]->
    [EatAuthenticityVerified($Attester, $Verifier, signed_EAT, ~n), UsedNonce(~n)] //


rule verificationSuccess:
    [EatAuthenticityVerified($Attester, $Verifier, signed_EAT, ~n)]
    --[Verification_success($Attester, $Verifier, signed_EAT, ~n)]->
    []


// Mark a nonce as used globally
rule MarkNonceAsUsed:
    [UsedNonce(~n)]
    -->
    [UsedNonceDeb(~n)]


restriction Equality:
   "All x y #i . Eq(x,y) @i ==> x=y "    


restriction OnlyOneIdentity:
    "All A ltk1 ltk2 #i #j. Create_ident(A,ltk1) @i & Create_ident(A,ltk2) @j ==> ltk1=ltk2"




//==========================================================================================================================================================
// Lemmas
//==========================================================================================================================================================

// sanity check: the protocol gets to the end with only non-compormised parties
// if the Attester never turn rouge (i.e. AttesterCompromise never happens), the protocol still runs to the end (i.e. we reach the event VerifierVerifiesEat
// lemma sanity_check:
// "
// All Attester Verifier signed_EAT n #k .
//     (
//         VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @k
//     ) 
//     ==> 
//     (
//         Ex signed_nonce #t #i .
//             VerifierSendsNonce(Attester, Verifier, signed_nonce) @t &
//             AttesterSendsEatGood(Attester, Verifier, signed_EAT, signed_nonce) @i &
//             // Eq(signed_nonce1, signed_nonce2) @k &
//             Eq(signed_nonce, n) @k &
//             not (Ex #j. AttesterCompromise(Attester) @j & #j < #i) &
//             #t < #i & 
//             #i < #k
//     )
// "

lemma sanity_check:
"
All Attester Verifier signed_EAT n #k .
    (
        // VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @k
        Verification_success(Attester, Verifier, signed_EAT, n) @k
    ) 
    ==> 
    (
        Ex signed_nonce #t #i .
            VerifierSendsNonce(Attester, Verifier, signed_nonce) @t &
            AttesterSendsEatGood(Attester, Verifier, signed_EAT, signed_nonce) @i &
            // Eq(signed_nonce1, signed_nonce2) @k &
            // Eq(signed_nonce, n) @k &
            not (Ex #j. AttesterCompromise(Attester) @j & #j < #i) &
            #t < #i & 
            #i < #k
    )
"








//The verifier can't successfully verify an attester that is in a "bad state".
//The verifier can't successfully verify an eat not send by the attester
//The verifier can't successfully verify an eat with a wrong nonce
lemma cannot_succesfully_verify_EAT_not_send_by_Attester:
 "
 All Attester Verifier signed_EAT n #i . 
    (
        VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @i
    )
    ==> (Ex signed_nonce #j . 
            AttesterSendsEatGood(Attester, Verifier, signed_EAT, signed_nonce) @j &
            #j < #i)
            // "or the attester was compromised before @i, and we didn't regain control of the attester while the verifier sent the nonce" 
 "




lemma verify_nonce_not_send_by_Verifier:
"
All Attester Verifier signed_EAT signed_nonce n #i #t .
    (
        VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @i &
        AttesterSendsEatGood(Attester, Verifier, signed_EAT, signed_nonce) @t &
        #t < #i
    )
    ==> 
    not (
        Ex #j .
            VerifierSendsNonce(Attester, Verifier, signed_nonce) @j &
            #j < #t
    )
"

// add a lemma that shows that agreement doesn't hold from the attester's point of view
lemma attester_does_not_agree_on_nonce_origin:
exists-trace
"
All Attester Verifier signed_EAT signed_nonce #t .
    (
        AttesterSendsEatGood(Attester, Verifier, signed_EAT, signed_nonce) @t
    )
    ==> 
        not (Ex #j .
            VerifierSendsNonce(Attester, Verifier, signed_nonce) @j &
            #j < #t
    )
"



//K never learns the attesters long term key
lemma attester_private_key_compromised:
 "
 All Attester Verifier signed_EAT ltk n #i #k .
    ( 
        Create_ident(Attester, ltk) @k &
        VerifierVerifiesEat(Attester, Verifier, signed_EAT, n) @i 
    )
    ==> not(Ex #j .
                K(ltk) @j & j<i &
                k<i)
 "


 lemma nonce_freshness_across_sessions:
 "
 All Attester Verifier n #i #j .
     (
         VerifierSendsNonce(Attester, Verifier, n) @i &
         VerifierSendsNonce(Attester, Verifier, n) @j
     )
     ==> #i = #j
 "


end
